/**
 * ğŸ§  Pricing Engine - Centralized pricing computations & normalization
 * Ù‡Ø¯Ù Ø§Ù„Ù…Ù„Ù: ØªÙˆØ­ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„ØªØ³Ø¹ÙŠØ± (subtotal + Ø§Ù„Ù†Ø³Ø¨ Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ© + breakdown)
 * ÙˆØ§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ ÙÙŠ ÙƒÙ„ Ù…Ù† TenderPricingProcess Ùˆ TenderDetails Ù„Ø¶Ù…Ø§Ù† Ù…ØµØ¯Ø± ÙˆØ§Ø­Ø¯ Ù„Ù„Ø­Ù‚ÙŠÙ‚Ø©.
 */
import type { DefaultPercentages } from './pricingService'
import { buildPricingMap } from '@/shared/utils/pricing/normalizePricing'
import type { NormalizedPricingItem } from '@/shared/utils/pricing/normalizePricing'
import type {
  PricingItemInput,
  PricingResource,
  RawPricingInput,
} from '@/shared/utils/pricing/pricingHelpers'
import { getPricingConfig } from '@/shared/constants/pricingConstants'

export interface ItemBreakdown {
  materials: number
  labor: number
  equipment: number
  subcontractors: number
  administrative: number
  operational: number
  profit: number
  subtotal: number
  total: number // = subtotal + admin + operational + profit
}

export interface EnrichedPricingItem extends NormalizedPricingItem {
  itemNumber?: string
  breakdown: ItemBreakdown
  adminPercentage: number
  operationalPercentage: number
  profitPercentage: number
  isPriced: boolean
}

// NOTE: DEFAULT_PERCENTAGES now proxies pricingConstants config to keep backward compatibility
export const DEFAULT_PERCENTAGES: DefaultPercentages = { ...getPricingConfig().defaultPercentages }

type PercentageOverrides = Partial<DefaultPercentages>

interface PercentageCarrier {
  additionalPercentages?: PercentageOverrides
  defaultPercentages?: PercentageOverrides
}

const resolveFallback = (fallback?: DefaultPercentages): DefaultPercentages =>
  fallback ?? DEFAULT_PERCENTAGES

export function getEffectivePercentages(
  entry: PercentageCarrier | undefined,
  fallback?: DefaultPercentages,
): DefaultPercentages {
  const base = resolveFallback(fallback)
  const source = entry?.additionalPercentages ?? entry?.defaultPercentages ?? {}
  return {
    administrative:
      typeof source.administrative === 'number' ? source.administrative : base.administrative,
    operational: typeof source.operational === 'number' ? source.operational : base.operational,
    profit: typeof source.profit === 'number' ? source.profit : base.profit,
  }
}

const sumResourceTotals = (resources: PricingResource[] | undefined): number => {
  if (!resources?.length) return 0
  return resources.reduce((sum, resource) => {
    const total = typeof resource.total === 'number' ? resource.total : undefined
    if (total !== undefined) return sum + total

    const price = typeof resource.price === 'number' ? resource.price : undefined
    const quantity = typeof resource.quantity === 'number' ? resource.quantity : undefined

    if (price !== undefined && quantity !== undefined) return sum + price * quantity
    if (price !== undefined) return sum + price
    return sum
  }, 0)
}

export function computeBreakdown(
  entry: NormalizedPricingItem,
  percentages: DefaultPercentages,
): ItemBreakdown {
  const materials = sumResourceTotals(entry.materials)
  const labor = sumResourceTotals(entry.labor)
  const equipment = sumResourceTotals(entry.equipment)
  const subcontractors = sumResourceTotals(entry.subcontractors)
  const subtotal = materials + labor + equipment + subcontractors
  const administrative = subtotal * (percentages.administrative / 100)
  const operational = subtotal * (percentages.operational / 100)
  const profit = subtotal * (percentages.profit / 100)
  const total = subtotal + administrative + operational + profit
  return {
    materials,
    labor,
    equipment,
    subcontractors,
    administrative,
    operational,
    profit,
    subtotal,
    total,
  }
}

export function enrichPricingItems(
  rawPricing: RawPricingInput,
  originalItems: PricingItemInput[],
  defaults?: DefaultPercentages,
): EnrichedPricingItem[] {
  type PricingMapSource = Parameters<typeof buildPricingMap>[0]
  const pricingMap = buildPricingMap(rawPricing as PricingMapSource)
  const result: EnrichedPricingItem[] = []
  let idx = 0
  const effectiveDefaults = resolveFallback(defaults)

  // Helper: detect placeholder / weak description generated by normalization
  const isPlaceholderDescription = (desc: unknown): boolean => {
    if (desc == null) return true
    const s = String(desc).trim()
    if (!s) return true
    // Arabic placeholders variants + generic 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'
    return /ØºÙŠØ±\s*Ù…Ø­Ø¯Ø¯/.test(s) || /^Ø¨Ù†Ø¯\s*(?:BOQ)?\s*$/i.test(s) || /^Ø¨Ù†Ø¯\s+ØºÙŠØ±\s+Ù…Ø­Ø¯Ø¯/i.test(s)
  }
  const isWeakUnit = (unit: unknown): boolean => {
    if (unit == null) return true
    const s = String(unit).trim()
    return !s || s === '-' || s === 'â€”'
  }
  const deriveBetterDescription = (
    entry: NormalizedPricingItem | undefined,
    original: PricingItemInput,
    fallbackIdx: number,
  ): string => {
    if (entry && !isPlaceholderDescription(entry.description)) return entry.description
    // try richer fields from original
    const cand =
      original.description ??
      (original as Record<string, unknown>).itemName ??
      original.name ??
      original.title ??
      (original as Record<string, unknown>).specifications ??
      (original as Record<string, unknown>).details ??
      (original as Record<string, unknown>).label ??
      (original as Record<string, unknown>).text
    return cand && !isPlaceholderDescription(cand) ? String(cand) : `Ø§Ù„Ø¨Ù†Ø¯ ${fallbackIdx}`
  }
  const deriveBetterUnit = (
    entry: NormalizedPricingItem | undefined,
    original: PricingItemInput,
  ): string => {
    if (entry && !isWeakUnit(entry.unit)) return entry.unit
    const candidate = original.unit ?? (original as Record<string, unknown>).uom
    if (candidate && !isWeakUnit(candidate)) return String(candidate)
    return entry?.unit ?? 'ÙˆØ­Ø¯Ø©'
  }
  for (const original of originalItems) {
    idx++
    const entry = pricingMap.get(original.id)
    if (!entry) {
      const fallbackItem: EnrichedPricingItem = {
        id: String(original.id),
        description: deriveBetterDescription(undefined, original, idx),
        unit: deriveBetterUnit(undefined, original),
        quantity: original.quantity ?? 0,
        unitPrice: 0,
        materials: [],
        labor: [],
        equipment: [],
        subcontractors: [],
        breakdown: {
          materials: 0,
          labor: 0,
          equipment: 0,
          subcontractors: 0,
          administrative: 0,
          operational: 0,
          profit: 0,
          subtotal: 0,
          total: 0,
        },
        adminPercentage: effectiveDefaults.administrative,
        operationalPercentage: effectiveDefaults.operational,
        profitPercentage: effectiveDefaults.profit,
        isPriced: false,
        itemNumber: original.itemNumber ?? String(idx).padStart(2, '0'),
        additionalPercentages: { ...effectiveDefaults },
        totalPrice: 0,
        finalPrice: 0,
        __raw: original,
      }
      result.push(fallbackItem)
      continue
    }
    const percentages = getEffectivePercentages(entry, effectiveDefaults)
    const breakdown = computeBreakdown(entry, percentages)
    const quantity = original.quantity ?? entry.quantity ?? 0
    // Align with legacy semantics: breakdown.total represents unit price (not per-item total)
    const unitPrice = breakdown.total
    // Patch description/unit when placeholders leaked from normalization
    const patchedDescription = deriveBetterDescription(entry, original, idx)
    const patchedUnit = deriveBetterUnit(entry, original)
    const enrichedItem: EnrichedPricingItem = {
      ...entry,
      description: patchedDescription,
      unit: patchedUnit,
      quantity,
      itemNumber: original.itemNumber ?? String(idx).padStart(2, '0'),
      unitPrice: +unitPrice.toFixed(2),
      totalPrice: +(unitPrice * quantity).toFixed(2),
      breakdown,
      adminPercentage: percentages.administrative,
      operationalPercentage: percentages.operational,
      profitPercentage: percentages.profit,
      isPriced: breakdown.subtotal > 0,
      materials: entry.materials ?? [],
      labor: entry.labor ?? [],
      equipment: entry.equipment ?? [],
      subcontractors: entry.subcontractors ?? [],
      finalPrice: +(unitPrice * quantity).toFixed(2),
    }
    result.push(enrichedItem)
  }
  // Ø¹Ù†Ø§ØµØ± Ù„ÙŠØ³ Ù„Ù‡Ø§ Ø£ØµÙ„ ÙÙŠ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø£ØµÙ„ÙŠ
  for (const [id, entry] of pricingMap.entries()) {
    if (result.find((r) => r.id === id)) continue
    idx++
    const percentages = getEffectivePercentages(entry, effectiveDefaults)
    const breakdown = computeBreakdown(entry, percentages)
    const quantity = entry.quantity ?? 0
    const unitPrice = breakdown.total
    const patchedDescription = isPlaceholderDescription(entry.description)
      ? entry.description || `Ø§Ù„Ø¨Ù†Ø¯ ${idx}`
      : entry.description
    const patchedUnit = isWeakUnit(entry.unit) ? entry.unit || 'ÙˆØ­Ø¯Ø©' : entry.unit
    const enrichedOrphan: EnrichedPricingItem = {
      ...entry,
      description: patchedDescription,
      unit: patchedUnit,
      itemNumber: String(idx).padStart(2, '0'),
      quantity,
      unitPrice: +unitPrice.toFixed(2),
      totalPrice: +(unitPrice * quantity).toFixed(2),
      breakdown,
      adminPercentage: percentages.administrative,
      operationalPercentage: percentages.operational,
      profitPercentage: percentages.profit,
      isPriced: breakdown.subtotal > 0,
      materials: entry.materials ?? [],
      labor: entry.labor ?? [],
      equipment: entry.equipment ?? [],
      subcontractors: entry.subcontractors ?? [],
      finalPrice: +(unitPrice * quantity).toFixed(2),
    }
    result.push(enrichedOrphan)
  }
  return result
}

export function aggregateTotals(items: EnrichedPricingItem[]) {
  const cfg = getPricingConfig()
  const totalValue = items.reduce((s, it) => s + (it.totalPrice || 0), 0)
  const totals = {
    totalValue,
    vatAmount: +(totalValue * cfg.vatRate).toFixed(2),
    totalWithVat: +(totalValue * (1 + cfg.vatRate)).toFixed(2),
    profit: items.reduce((s, it) => s + (it.breakdown?.profit || 0), 0),
    administrative: items.reduce((s, it) => s + (it.breakdown?.administrative || 0), 0),
    operational: items.reduce((s, it) => s + (it.breakdown?.operational || 0), 0),
  }
  const adminOperational = totals.administrative + totals.operational
  const profitPercentage = totalValue > 0 ? +((totals.profit / totalValue) * 100).toFixed(4) : 0
  const adminOperationalPercentage =
    totalValue > 0 ? +((adminOperational / totalValue) * 100).toFixed(4) : 0
  return {
    ...totals,
    adminOperational,
    vatRate: cfg.vatRate,
    profitPercentage,
    adminOperationalPercentage,
  }
}

// Export a version tag to help tests ensure latest engine logic loaded
export const PRICING_ENGINE_VERSION = 'phase3-unitprice-fix'
