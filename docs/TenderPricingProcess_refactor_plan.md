# خطة تحسين مكون "TenderPricingProcess"

## نظرة عامة

تهدف هذه الخطة إلى تفكيك منطق الصفحة الحالية إلى وحدات أصغر قابلة للاختبار، وربطها بالكامل بالنظام المركزي للحسابات والتصميمات والتخزين، مع التخلص من الأكواد المكررة والبيانات التجريبية. تنفَّذ المهام وفق أفضل الممارسات المعتمدة في المشروع (SOLID، مبدأ المصدر الواحد للحقيقة، تصميم يعتمد على المكونات) مع الحفاظ على استقرار التجربة الحالية أثناء الانتقال التدريجي.

## المبادئ العامة

- الاعتماد على النظام المركزي (محرك التسعير، خدمات الحفظ، متجر المكونات) كمصدر وحيد للحقيقة.
- تجزئة المكوّنات الكبيرة إلى وحدات صغيرة ذات مسؤوليات واضحة، مدعومة باختبارات.
- إزالة أي بيانات تجريبية أو منطق legacy غير مستخدم.
- استعمال مكونات التصميم الموحدة (`ui/`) أو توفير بدائل مطابقة قبل أي تطوير بصري.
- الحفاظ على إمكانية الرجوع (feature flags، نسخ احتياطية) أثناء عملية النقل.

## المرحلة 1: التحضير وتحليل التبعيات

1. جرد الاستيرادات الحالية ومصادر البيانات في `TenderPricingProcess.tsx` وتوثيقها في تذاكر فرعية.
2. مراجعة الهوكس الموجودة تحت `pricing/tender-pricing-process/hooks` وتحديد ما يمكن است reutilize.
3. التحقق من تغطية الاختبارات الحالية (`npm run -s test`) وتحديد الفجوات (خاصة لحساب التكاليف ومزامنة الحالة).
4. إعداد خطة رجوع سريعة (git branch، tagging للنسخة الحالية).

### تقدم المرحلة 1 (2025-10-20)

- **حصر الاستيرادات**: تم تصنيف الاستيرادات في `src/components/TenderPricingProcess.tsx` إلى أربع فئات رئيسية — خدمات/هوكس (`pricingService`, `pricingDataSyncService`, `useDomainPricingEngine`, `useEditableTenderPricing`, `useSystemData`, `useCurrencyFormatter`)، أدوات مشتركة (`pricingHelpers`, `defaultPercentagesPropagation`, `storage`, `helpers`, `events/bus`)، أنواع وواجهات (`@/types/pricing`, `@/types/boq`, `@/application/services/pricingEngine`)، ومكونات واجهة (`ui/button`, `ui/tabs`, `ui/dialog`, `PricingTemplateManager` وغيرها). هذا الجرد جاهز للاستخدام في تذاكر التفكيك.
- **مصادر البيانات**: تم تلخيص مصادر بيانات البنود والتسعير (حقول `tender` المتنوعة، المرفقات، التخزين المحلي، خدمات التسعير، مستودع BOQ) وتوثيق احتياج توحيدها تحت المحرك المركزي في المراحل اللاحقة.
- **مراجعة الهوكس المتاحة**: تم تقييم `useTenderPricingState`, `useTenderPricingCalculations`, `useTenderPricingPersistence` الموجودة في `pricing/tender-pricing-process/hooks`. الهوكس تغطي الوظائف التي ينفذها المكوّن حالياً (إدارة العرض/المؤشر، الحسابات، الحفظ والمزامنة)، ويمكن إعادة استخدامها مع تعديلات طفيفة على واجهات الإدخال.
- **الاختبارات وخطة الرجوع**: تم تشغيل `npm run -s test` (Vitest) بنجاح لضمان سلامة baseline قبل التفكيك؛ لا توجد إخفاقات حالية. خطة الرجوع لا تزال تعتمد على العمل داخل فرع `optimization/security-and-quality-improvements` مع الحفاظ على نقطة استرجاع (baseline commit) قبل أي تغييرات كبيرة.

## المرحلة 2: توحيد الأنواع والواجهات المشتركة

1. نقل/استيراد جميع تعريفات الأنواع من `TenderPricingProcess.tsx` إلى `pricing/tender-pricing-process/types.ts` (إن لم تكن موجودة) واعتمادها في كل الملفات.
2. إنشاء وحدات حارسة (type guards) مشتركة في `utils/pricingHelpers.ts` وإحلالها محل النسخ المحلية.
3. تحديث الوحدات التابعة (مثل `useTenderPricingPersistence`) لاستخدام الأنواع الموحدة.

### تقدم المرحلة 2 (2025-10-20)

- **استبدال التعريفات المحلية**: تم إزالة تعريفات `QuantityItem`, `DraftPricingItem`, `TenderWithPricingSources` وغيرها من `src/components/TenderPricingProcess.tsx` والاعتماد على الاستيراد من `pricing/tender-pricing-process/types.ts` مع إعادة تصدير `TenderWithPricingSources` للحفاظ على واجهة الاستخدام الحالية.
- **تنظيف الاستيرادات**: تم تحديث استيرادات المكوّن لإزالة الأنواع غير المستخدمة (`PricingBreakdown`, `TenderAttachment`) وإضافة النوع المركزي `PricingTemplate`، ما ضمن التوافق مع قواعد ESLint/TypeScript ومنع `any` غير الضرورية.
- **التوافق مع مكوّن الملخص**: توفير معالجات موحدة للتعامل مع متطلبات `SummaryView` الحالية (إشعارات انتقال لتبويب التسعير) لحين تنفيذ دعم التحرير المباشر من الملخص ضمن خطة لاحقة.
- **التغطية بالاختبارات**: بعد عملية النقل، أعيد تشغيل إختبارات Vitest بنجاح للتحقق من خلو التعديلات من الانحدارات.
- **الحراس المشتركة**: تم نقل `isPricingData` و`isPricingEntry` إلى `src/utils/pricingHelpers.ts` وإعادة استخدامهما عبر الاستيراد في `TenderPricingProcess.tsx` تمهيداً لاعتمادها داخل الهوكس المرتبطة بالتخزين والمزامنة.
- **تحديث الهوكس**: تمت إزالة التعريفات المحلية في `useTenderPricingPersistence` لصالح الأنواع المشتركة (`QuantityItem`, `PricingStatusSnapshot`، وغيرها) مع الاستفادة من `isPricingEntry` قبل التسلسل إلى خدمات الحفظ والمزامنة.
- **حارس التبويبات**: تم تعريف `PricingViewName` و`isPricingViewName` في `pricing/tender-pricing-process/types.ts` واستخدامهما في كلٍ من `TenderPricingProcess.tsx` و`useTenderPricingState.ts` لتفادي ازدواجية تعريف التبويبات وضمان الاتساق مع بقية الوحدات.
- **الخطوة التالية**: الشروع في المرحلة الثالثة بدمج `useTenderPricingState` داخل المكوّن الرئيسي وإزاحة إدارة الحالة المحلية تمهيداً لتفكيك التبويبات.

## المرحلة 3: إعادة استخدام الهوكس المتاحة

1. استبدال الحالات المحلية (current view، المؤشر الحالي، حوار الخروج) باستدعاء `useTenderPricingState`.
2. اعتماد `useTenderPricingCalculations` لجميع الحسابات وإزالة المنطق المكرر داخل المكوّن الرئيسي.
3. دمج `useTenderPricingPersistence` لإدارة الحفظ، المزامنة، وتحديث حالة المناقصة، مع نقل أي فروق مطلوبة إلى الهوك نفسه على هيئة إعدادات أو callbacks.
4. إضافة اختبارات وحدات للهوكس لتغطية المسارات الحيوية (احتساب المواد مع الهدر، الاسترجاع من النسخ الاحتياطية، broadcasting للأحداث).

### تقدم المرحلة 3 (2025-10-20)

- **توحيد إدارة الحالة**: تم استبدال الحالة المحلية الخاصة بالمؤشر الحالي، التبويب النشط، وحوار تأكيد الخروج باستهلاك `useTenderPricingState`. أصبح المكوّن يعتمد على `markDirty`, `changeView`, و`requestLeave` من الهوك نفسه، ما أزال الازدواجية وضمن سلوكاً موحداً لحماية المسودات.
- **التكامل مع واجهات الملخص**: تم تمرير `changeView` و`setCurrentItemIndex` من الهوك مباشرةً إلى `SummaryView` و`Tabs` لضمان تحديث العرض عبر نقطة مركزية واحدة.
- **اعتماد هوك الحسابات المركزي**: تم دمج `useTenderPricingCalculations` بالكامل وحذف دوال الحساب المتناثرة داخل المكوّن، ما وحّد طريقة احتساب نسب الهدر، الضريبة، والإجماليات وأعاد استخدامها في تبويب الملخص.
- **إعادة تأطير منطق الحفظ**: نُقلت مسؤوليّات الحفظ والمزامنة إلى `useTenderPricingPersistence` بعد توسيعه ليشمل تحديثات BOQ التفصيلية، أحداث `pricingDataUpdated`, ومزامنة حالة المنافسة، مع إزالة المنطق المكرر من المكوّن الرئيسي.
- **اختبارات التحقق**: أعيد تشغيل `npm run -s test` بنجاح بعد التعديلات للتأكد من سلامة التكامل.
- **الخطوة التالية**: تغطية الهوكس الجديدة باختبارات وحدات مركزة (الحسابات، المزامنة) ومراجعة التدفق مع فريق النطاق قبل الانتقال إلى المرحلة الرابعة.

## المرحلة 4: تفكيك التبويبات والمكوّنات البصرية

1. نقل كل تبويب (`summary`, `pricing`, `technical`) إلى ملف مكوّن منفصل (إذا لم يكن موجوداً بالفعل)، مع حصر المكوّن الرئيسي في تنسيق الحالة وحقن البيانات.
2. توحيد عناصر الإدخال والتحكم داخل التبويبات باستخدام مكونات النظام (`Input`, `Label`, `FormField`, `Button`, `Tabs`) بدلاً من عناصر HTML الخام.
3. إنشاء مجلد فرعي `pricing/tender-pricing-process/views` أو `sections` لإيواء البنى الفرعية، وربطها عبر barrel file (`index.ts`).
4. تحديث الاستيرادات في `TenderPricingProcess.tsx` والملفات المرتبطة لتعكس الهيكلة الجديدة.

### تقدم المرحلة 4 (2025-10-21)

- **فصل التبويبات**: تم اعتماد المكوّن الجديد `pricing/tender-pricing-process/views/TenderPricingTabs.tsx` لعرض التبويبات الثلاثة، وتمرير خصائص العرض من المكوّن الرئيسي فقط.
- **تنظيف المكوّن الرئيسي**: انحصر `TenderPricingProcess.tsx` في تنسيق البيانات والحالة، بينما أصبحت مكونات العرض مسؤولة عن التقديم البصري.
- **تحديث الاستيرادات**: تم تحديث الاستيرادات في المكوّن الرئيسي والهوكس المرتبطة للتوافق مع المسار الجديد للتبويبات.
- **الخطوة التالية**: مراجعة تبويب `SummaryView` لاحقاً لتقليل الاعتماد على حالات محلية إضافية واستكمال توحيد عناصر الإدخال.

## المرحلة 5: تنظيف البيانات التجريبية والمنطق الزائد

1. إزالة البيانات الافتراضية (DefaultQuantityItems) واستبدالها بالتعامل المنظم مع حالات عدم توفر البيانات (إظهار EmptyState فقط).
2. حذف سجلات `console.log`، `console.warn` التجريبية أو استبدالها بمستوى logging مركزي قابل للتعطيل.
3. إزالة أي `setTimeout` غير ضروري واستبداله بآليات تعتمد على الحالة/الوعود إن لزم.
4. التأكد من عدم تكرار الاستدعاءات (`updateTenderStatus()` وغيره) ومراجعة شروط التأثيرات.

### تقدم المرحلة 5 (2025-10-21)

- **إزالة التسجيلات المؤقتة**: تم استبدال جميع استدعاءات `console.*` في `TenderPricingProcess.tsx` والهوكس المرتبطة (`useTenderPricingPersistence`, `useTenderPricingCalculations`, `useTenderPricingState`, `usePricingTemplates`) بسجلات تدقيق مركزية عبر `recordAuditEvent` مع بيانات وصفية سياقية.
- **تنظيف المنطق الزائد**: تمت مراجعة معالجي القوالب، التحديث، النسخ الاحتياطي، والتصدير لتقليل المسارات التجريبية وإضافة توجيهات تدقيق واضحة عند الإخفاق.
- **المرجعية المركزية للأخطاء**: أصبح تدفق إخفاقات الحفظ/الاسترجاع متكاملًا مع نظام التنبيهات (Toast) وسجل التدقيق، ما يسمح بمراقبة الإنتاج بدون الاعتماد على كونسول المتصفح.
- **الخطوة التالية**: متابعة مراجعة حالات edge المرتبطة بالتنسيق والتحويل (مثل `formatQuantity`) وإضافة اختبارات وحدات لتغطية سيناريوهات الاسترجاع والتصدير.

## المرحلة 6: تحسين التكامل مع النظام المركزي للحسابات والتصميم

1. توحيد مسار القراءة والكتابة مع `useDomainPricingEngine` وجعل محرك التسعير المصدر الوحيد للأرقام المعروضة، مع الاحتفاظ بمسار fallback عن طريق ميزات التحكم الموجودة.
2. مراجعة استخدام خدمات التصميم (`ui/` components، الثيم المركزي) والتأكد من تطبيقها على كل الحقول، الجداول، الإجراءات.
3. إضافة لائحة تدقيق داخلية للتأكد من أن جميع العمليات (حفظ، مزامنة، حساب ضريبة، بناء BOQ) تمر عبر الخدمات المركزية.
4. تحديث الوثائق (`ARCHITECTURE_PRICING_LAYER.md`) لتعكس المسارات الجديدة.

## المرحلة 7: الاختبارات والتحقق النهائي

1. تشغيل وحدات الاختبار والتأكد من تجاوزها (`npm run -s test`).
2. تنفيذ اختبارات دخانية يدوية: إدخال بيانات تسعير، تفعيل الحفظ التلقائي، استرجاع نسخة احتياطية، التبديل بين التبويبات.
3. مراجعة سجلات المتصفح والكونسول للتأكد من خلوها من التحذيرات الجديدة.
4. إعداد ملخص تغييرات (Change Log) وربطه بتذكرة العمل.

## المرحلة 8: الإطلاق والمتابعة

1. رفع طلب دمج مع توضيح التأثيرات والاختبارات.
2. مراقبة السجلات بعد الإطلاق للتأكد من عدم ظهور أخطاء في المزامنة أو الحفظ.
3. جدولة جولة تحسين لاحقة لتعزيز الأداء (memoization إضافي، lazy loading للتبويبات إذا لزم).

## ملاحظات خاصة

- **التبويبات**: سيتم عزل منطق كل تبويب داخل ملفات منفصلة لتقليل حجم المكوّن الرئيسي وتحسين قابلية الصيانة.
- **البيانات التجريبية**: يجب حذف أي بيانات افتراضية أو placeholders لتعويض غياب جدول الكميات، والاكتفاء بمؤشر بصري (EmptyState) في حال عدم توفر بيانات حقيقية.
- **النظام البصري المركزي**: المكوّن الرئيسي يستخدم بعض مكونات `ui/` (مثل `Button`, `Badge`, `Tabs`) لكنه ما زال يحتوي على عناصر HTML خام. ضمن المرحلة الرابعة والسادسة ستتم مراجعة شاملة لاستبدال جميع العناصر بعناصر من مكتبة التصميم الرسمية أو توفير مكونات جديدة عند الحاجة.
- **الالتزام بأفضل الممارسات**: كل مرحلة تتضمن أعمال مراجعة واختبار لضمان التطابق مع مبادئ التصميم والنظام المركزي.
